#!/usr/bin/env bash

set -e
set -u
set -o pipefail

if ! [[ "$#" -eq 4 ]]; then
  echo """
  Desc:  Prepares an image for launching instances
  Usage: $(basename "$0") ROOT IMAGE_ID PORT ANON_FILE
  Example:

      $(basename "$0") /draupnir 999 6543 anon.sql

  The steps taken are:

  1. Extract and remove any tar files in the directory
  2. Remove pid files, if present
  3. Set the correct permissions to boot postgres
  4. Install our own postgresql.conf and pg_hba.conf
  5. Boot postgres
  6. Run the anonymisation script
  7. Stop postgres
  8. Take a BTRFS snapshot of the directory
  """
  exit 1
fi

PG_CTL=/usr/lib/postgresql/11/bin/pg_ctl
VACUUMDB=/usr/lib/postgresql/11/bin/vacuumdb
PSQL=/usr/bin/psql

ROOT=$1
ID=$2
PORT=$3
ANON_FILE=$4

# TODO: validate input

UPLOAD_PATH="${ROOT}/image_uploads/${ID}"
SNAPSHOT_PATH="${ROOT}/image_snapshots/${ID}"

set -x

sudo mkdir -p "${UPLOAD_PATH}/tmp"

if sudo sh -c "ls ${UPLOAD_PATH}/*.tar*"; then
	sudo sh -c "tar xf ${UPLOAD_PATH}/*.tar* -C ${UPLOAD_PATH}/tmp"
	sudo sh -c "mv ${UPLOAD_PATH}/tmp/* ${UPLOAD_PATH}/"
	sudo rmdir "${UPLOAD_PATH}/tmp"
	sudo sh -c "rm -f ${UPLOAD_PATH}/*.tar*" # remove the compressed backup file(s)
fi

if ! sudo -u postgres /usr/lib/postgresql/11/bin/pg_controldata "${UPLOAD_PATH}"; then
	echo "image upload is not valid postgresql data directory"
	exit 255
fi

sudo rm -f "${UPLOAD_PATH}/postmaster.pid"
sudo rm -f "${UPLOAD_PATH}/postmaster.opts"
sudo chown -R postgres "$UPLOAD_PATH"
sudo chmod 700 "$UPLOAD_PATH"

# Install our own postgresql.conf
cat > "${UPLOAD_PATH}/postgresql.conf" <<- EOF
datestyle = 'iso, mdy'
default_text_search_config = 'pg_catalog.english'
lc_messages = 'C'
listen_addresses = '*'
log_autovacuum_min_duration = 0
log_checkpoints = 'on'
log_connections = 'on'
log_disconnections = 'on'
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a '
log_lock_waits = 'on'
log_min_duration_statement = 500
log_temp_files = 0
maintenance_work_mem = '256MB'
max_connections = 150
shared_preload_libraries = 'pg_stat_statements'
ssl = on
ssl_cert_file = '/etc/ssl/certs/ssl-cert-snakeoil.pem'
ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'
ssl_ciphers = 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384'
ssl_prefer_server_ciphers = 'on'
temp_file_limit = 5242880 # 5GiB
work_mem = '128MB'

# Turn off hot standby as we won't ever need to run queries against this
# database while it's in recovery. We also want to reduce- as much as is
# possible- the amount of WAL we write during finalisation, as this step usually
# requires a significant amount of IO. Similarly, fsync should be turned off
# during finalisation.
hot_standby = 'off'
max_wal_senders = 0
wal_level = 'minimal'
fsync = 'off'
EOF

LOG_FILE="/var/log/postgresql/image_${ID}"

# Start postgres
sudo -u postgres $PG_CTL -w -D "$UPLOAD_PATH" -o "-p $PORT" -l "${LOG_FILE}" start

# We need to wait for postgres to boot and announce that the recovery has
# completed. Ideally WAL recovery shouldn't take long, but for high volume
# databases Postgres needs a window to catch-up from the last checkpoint.
TIMEOUT=600 # 10m
sudo -u postgres touch "${LOG_FILE}" # otherwise we'll fail grep'ing the file
until grep "database system is ready to accept connections" "${LOG_FILE}"
do
  if [ $(( TIMEOUT-- )) -eq 0 ];
  then
    cat "${LOG_FILE}" >&2
    echo "Postgres recovery failed, timed out waiting for recovery" >&2
    exit 255
  fi
  sleep 1
done

# Create a user to perform admin operations with
sudo -u postgres createuser --port="$PORT" --createdb --createrole --superuser draupnir-admin

# Create a user that will be used to connect to the instance, which does not
# have superuser privileges, or the ability to create roles with these.
# It's important to ensure that the user does not have superuser privileges, as
# otherwise they will have access to read any file on the filesystem that the
# user the process is running under has access to.
sudo -u postgres createuser --port="$PORT" --createdb draupnir

# Perform anonymisation. Do this before reassigning ownership, in case the
# anonymisation script creates new objects owned by the draupnir-admin user.
echo "Executing anonymisation script $ANON_FILE"
sudo cat "$ANON_FILE" | sudo -u postgres "$PSQL" -p "$PORT" --username=draupnir-admin postgres

echo "Vacuum all the databases in the cluster"
sudo -u postgres $VACUUMDB --all --port="$PORT" --jobs="$(nproc)"

# Reassign the ownership of all objects (databases, tables, views etc.) from
# the current user to the 'draupnir' user.
# An assumption is made that the 'postgres' user is the superuser that was
# created at initdb time, and therefore is skipped as it's not possible to
# reassign all objects owned by this user. If this assumption does not hold,
# then errors may be reported.
pushd /tmp
sudo -u postgres psql -U draupnir-admin -d postgres -p "$PORT" -v ON_ERROR_STOP=1 --echo-errors -qAtc "SELECT datname FROM pg_database WHERE datistemplate = false;" \
  | while read -r database; do
    sudo -u postgres psql -U draupnir-admin -d postgres -p "$PORT" -v ON_ERROR_STOP=1 --echo-errors -qAtc "SELECT usename FROM pg_user WHERE usename <> 'postgres';" \
    | while read -r user; do
      echo "Changing ownership of ${database}/${user}"
      sudo -u postgres psql -U draupnir-admin -d "$database" -p "$PORT" -v ON_ERROR_STOP=1 --echo-errors -qAtc 'REASSIGN OWNED BY "'"${user}"'" TO draupnir;'
  done
done
popd

echo "Turning back on fsync and hot_standby wal level"
sed -i \
  "s/wal_level = 'off'/wal_level = 'hot_standby'/; s/fsync = 'off'/fsync = 'on'/" \
  "${UPLOAD_PATH}/postgresql.conf"

# The 'draupnir-admin' user is no longer required
sudo -u postgres dropuser --port="$PORT" draupnir-admin

sudo -u postgres $PG_CTL -D "$UPLOAD_PATH" -w stop
sudo rm -f "${UPLOAD_PATH}/postmaster.pid"
sudo rm -f "${UPLOAD_PATH}/postmaster.opts"

# Install our own pg_hba.conf, and ensure that it cannot be modified
cat > "${UPLOAD_PATH}/pg_hba.conf" <<EOF
# NOTE: The cert auth method is essential - without this the Draupnir instance
# will be accessible to anyone with knowledge of the host and port.
# Do not edit this unless you are absolutely certain of the consequences.
local   all     all                             trust
hostssl all     draupnir        0.0.0.0/0       cert    map=draupnir
EOF

# Draupnir instances run as the draupnir-instance user
find "${UPLOAD_PATH}" -user postgres -exec chown draupnir-instance {} \;
find "${UPLOAD_PATH}" -group postgres -exec chgrp draupnir-instance {} \;

chown root:draupnir-instance "${UPLOAD_PATH}/pg_hba.conf"
chmod 640 "${UPLOAD_PATH}/pg_hba.conf"
chattr +i "${UPLOAD_PATH}/pg_hba.conf"

btrfs subvolume snapshot "$UPLOAD_PATH" "$SNAPSHOT_PATH"

set +x
